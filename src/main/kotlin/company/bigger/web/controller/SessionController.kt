package company.bigger.web.controller

import company.bigger.dto.UserLoginModel
import company.bigger.dto.UserLoginModelResponse
import company.bigger.service.LoginService
import company.bigger.service.UserService
import org.springframework.beans.factory.annotation.Value
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.PathVariable
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController

/**
 * Session `/session` controller for log-in.
 * This is the only REST controller we have.
 * Note that we support one token per login name now only.
 * Also we still store the token inside the microservice so they do not survive the microservice restart.
 */
@RestController
class SessionController(
    @Value("\${user.password.hash:N}")
    private val USER_PASSWORD_HASH: String,

    @Value("\${user.locking.max_account_lock_minutes:180}")
    private val USER_LOCKING_MAX_ACCOUNT_LOCK_MINUTES: String,

    @Value("\${user.locking.max_inactive_period_day:180}")
    private val USER_LOCKING_MAX_INACTIVE_PERIOD_DAY: String,

    @Value("\${user.locking.max_password_age_day:365}")
    private val USER_LOCKING_MAX_PASSWORD_AGE_DAY: String,

    @Value("\${user.locking.max_login_attempt:10}")
    private val USER_LOCKING_MAX_LOGIN_ATTEMPT: String,

    /**
     * Secret key to be used by JWT.
     * This allows the microservices running to validate the token generated by another service instance once the token
     * is stored out of the microservice.
     */
    @Value("\${jwt.secret}") val jwtSecret: String,
    /**
     * Token issuer. This is checked in [isTokenValid].
     */
    @Value("\${jwt.issuer}") val jwtIssuer: String,
    /**
     * Token expiratation. The default is 10 days.
     */
    @Value("\${jwt.expiration:14400}") val jwtExpiration: Int
) {
    private val userService = UserService(
        LoginService(
            USER_PASSWORD_HASH, USER_LOCKING_MAX_ACCOUNT_LOCK_MINUTES.toInt(), USER_LOCKING_MAX_INACTIVE_PERIOD_DAY.toInt(),
            USER_LOCKING_MAX_PASSWORD_AGE_DAY.toInt(), USER_LOCKING_MAX_LOGIN_ATTEMPT.toInt()
        ),
        jwtSecret = jwtSecret,
        jwtIssuer = jwtIssuer
    )

    /**
     * Login and return token if the username and password are valid.
     * Note that when a user logs in, if the user was logged from somewhere else before, the previous token is invalidated.
     */
    @GetMapping()
    @RequestMapping(value = ["/session/{username}/login/{password}"])
    fun login(@PathVariable username: String, @PathVariable password: String): UserLoginModelResponse? {
        return userService.login(UserLoginModel(username, password))
    }

    /**
     * Validate a token and return the associated user
     */
    @GetMapping()
    @RequestMapping(value = ["/session/{token}/validate"])
    fun validateToken(@PathVariable token: String): UserLoginModelResponse? {
        return userService.validateToken(token)
    }
}